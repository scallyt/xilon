// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: projects.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProject = `-- name: CreateProject :one
INSERT INTO projects (customer_name, customer_id, project_name, chat_id, description, developer_id, status, start_date, end_date, budget)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, customer_name, customer_id, project_name, chat_id, description, developer_id, status, start_date, end_date, budget
`

type CreateProjectParams struct {
	CustomerName string         `json:"customer_name"`
	CustomerID   pgtype.UUID    `json:"customer_id"`
	ProjectName  string         `json:"project_name"`
	ChatID       pgtype.UUID    `json:"chat_id"`
	Description  pgtype.Text    `json:"description"`
	DeveloperID  pgtype.UUID    `json:"developer_id"`
	Status       string         `json:"status"`
	StartDate    pgtype.Date    `json:"start_date"`
	EndDate      pgtype.Date    `json:"end_date"`
	Budget       pgtype.Numeric `json:"budget"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.CustomerName,
		arg.CustomerID,
		arg.ProjectName,
		arg.ChatID,
		arg.Description,
		arg.DeveloperID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
		arg.Budget,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CustomerName,
		&i.CustomerID,
		&i.ProjectName,
		&i.ChatID,
		&i.Description,
		&i.DeveloperID,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.Budget,
	)
	return i, err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE id = $1
`

func (q *Queries) DeleteProject(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteProject, id)
	return err
}

const getAllProjectByUserId = `-- name: GetAllProjectByUserId :many
SELECT id, customer_name, customer_id, project_name, chat_id, description, developer_id, status, start_date, end_date, budget
FROM projects
WHERE developer_id = $1
ORDER BY start_date DESC
`

func (q *Queries) GetAllProjectByUserId(ctx context.Context, developerID pgtype.UUID) ([]Project, error) {
	rows, err := q.db.Query(ctx, getAllProjectByUserId, developerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CustomerName,
			&i.CustomerID,
			&i.ProjectName,
			&i.ChatID,
			&i.Description,
			&i.DeveloperID,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.Budget,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOneProjectById = `-- name: GetOneProjectById :one
SELECT id, customer_name, customer_id, project_name, chat_id, description, developer_id, status, start_date, end_date, budget
FROM projects
WHERE id = $1
`

func (q *Queries) GetOneProjectById(ctx context.Context, id pgtype.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getOneProjectById, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CustomerName,
		&i.CustomerID,
		&i.ProjectName,
		&i.ChatID,
		&i.Description,
		&i.DeveloperID,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.Budget,
	)
	return i, err
}

const getProject = `-- name: GetProject :one
SELECT id, customer_name, customer_id, project_name, chat_id, description, developer_id, status, start_date, end_date, budget
FROM projects
WHERE id = $1
`

func (q *Queries) GetProject(ctx context.Context, id pgtype.UUID) (Project, error) {
	row := q.db.QueryRow(ctx, getProject, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CustomerName,
		&i.CustomerID,
		&i.ProjectName,
		&i.ChatID,
		&i.Description,
		&i.DeveloperID,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.Budget,
	)
	return i, err
}

const getProjects = `-- name: GetProjects :many
SELECT id, customer_name, customer_id, project_name, chat_id, description, developer_id, status, start_date, end_date, budget
FROM projects
ORDER BY start_date DESC
LIMIT $1
OFFSET $2
`

type GetProjectsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetProjects(ctx context.Context, arg GetProjectsParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjects, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CustomerName,
			&i.CustomerID,
			&i.ProjectName,
			&i.ChatID,
			&i.Description,
			&i.DeveloperID,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.Budget,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByStatus = `-- name: GetProjectsByStatus :many
SELECT id, customer_name, customer_id, project_name, chat_id, description, developer_id, status, start_date, end_date, budget
FROM projects
WHERE status = $1
ORDER BY start_date DESC
LIMIT $2
OFFSET $3
`

type GetProjectsByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) GetProjectsByStatus(ctx context.Context, arg GetProjectsByStatusParams) ([]Project, error) {
	rows, err := q.db.Query(ctx, getProjectsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.CustomerName,
			&i.CustomerID,
			&i.ProjectName,
			&i.ChatID,
			&i.Description,
			&i.DeveloperID,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.Budget,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET customer_name = $2,
  customer_id = $3,
  project_name = $4,
  chat_id = $5,
  description = $6,
  developer_id = $7,
  status = $8,
  start_date = $9,
  end_date = $10,
  budget = $11
WHERE id = $1
RETURNING id, customer_name, customer_id, project_name, chat_id, description, developer_id, status, start_date, end_date, budget
`

type UpdateProjectParams struct {
	ID           pgtype.UUID    `json:"id"`
	CustomerName string         `json:"customer_name"`
	CustomerID   pgtype.UUID    `json:"customer_id"`
	ProjectName  string         `json:"project_name"`
	ChatID       pgtype.UUID    `json:"chat_id"`
	Description  pgtype.Text    `json:"description"`
	DeveloperID  pgtype.UUID    `json:"developer_id"`
	Status       string         `json:"status"`
	StartDate    pgtype.Date    `json:"start_date"`
	EndDate      pgtype.Date    `json:"end_date"`
	Budget       pgtype.Numeric `json:"budget"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.ID,
		arg.CustomerName,
		arg.CustomerID,
		arg.ProjectName,
		arg.ChatID,
		arg.Description,
		arg.DeveloperID,
		arg.Status,
		arg.StartDate,
		arg.EndDate,
		arg.Budget,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.CustomerName,
		&i.CustomerID,
		&i.ProjectName,
		&i.ChatID,
		&i.Description,
		&i.DeveloperID,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.Budget,
	)
	return i, err
}
